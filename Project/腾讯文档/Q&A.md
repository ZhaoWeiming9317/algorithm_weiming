Q:  为什么要做数据升级?
A：之前用的开源的协同算法 easysync。
- 它的可读性比较差，用的是一种正则匹配的方式匹配属性。
- 属性是平铺的，不是嵌套的，这样它的可扩展性会比较差。
后续我们改成了自研的协同算法。
- 将属性改成了嵌套式的，并且符合微软的OOXML规范，这个规范定义了标准的属性设置方式和用途，这样如果市面上所有支持这个规范的文档都是支持双向无损导入导出的。
- 我主要是负责将几个大模块与数据升级有关的模块进行升级，最后。还有也修改了最底层的代码，处理撤销和重做与冲突处理有关的逻辑。


Q：什么是OT算法?
A：OT算法的全程是operation transform，意思就是操作转换，其主要目的是为了修正由于协同冲突造成的错误的编辑操作，由此来转换用户的编辑操作，是一种协同冲突处理算法。
什么是协同冲突处理呢，举个例子(文档里面有一段文字abc，A用户要删除文字a，B用户要删除文字b，假设A已经删除了位置1的文字a，且已经push到服务端了，然而同时B已经删除了位置2的文字b，此时用户A收到了用户B的删除位置2的文字的操作信息，可是对于用户A来说，删掉a以后文档内部只有bc两个字符，如果还是删掉位置2的字符就相当于删掉了bc中的c，但是用户B实际上删掉的b，所以需要将用户B的操作从删掉位置2变成删掉位置1，而计算这个过程的函数就是之前transform函数，这个函数接受两个参数，a的操作和b的操作，然后根据插入，删除，修改属性等不同的操作类型来进行不同类型的transform操作，这些操作类型都是写在操作对象里面的)。

具体实现
因为要考虑的情况很多，我只说其中一种，就是刚才的例子，比如A删掉了位置1，B删掉了位置2，由于A删掉了位置1后，B删除位置2的信息应该变成B删除位置1才合适，在OT算法内部会看到A删掉的位置比B要靠前，所以B的位置就等于 B当前的位置减去A删掉的长度。删除与删除的OT算法是最简单，还有删除，修改，插入这三种情况排列组合的情况，也都在transform函数里面进行了操作转换。


Q：OT 算法双边和单边？
A：我们知道 OT 算法有单边和双边的区别
单边 OT 是指，当 A、B发生冲突后，A发生的冲突可能会 TODO: 请 AI 补充下

Q：什么是撤销/重做？它们是怎么实现的？
A：撤销就是Ctrl + Z，把上一次写过的东西撤回，重做就是把已经撤销的恢复回来。
实现方式是用两个栈来实现的，用户每做一次操作，会运用一种启发式的算法来判断这次操作是不是应该放入栈中，栈分为撤销栈和重做栈。
现在我们只关注撤销栈，当撤销栈内部有很多 mutation, 我们可以理解为冲突处理的基本单位。在mutation上有一个新的封装层级叫做 operation，一个 operation 可以对应一个或多个 mutation。
Mutation 是冲突处理的基本单位。
Operation 是 Mutation 的包装结构，可以对多个 mutation 进行处理，并且做一些更加抽象的逻辑。

'''
Operation apply 后的 range 变化 e.g. 例如当前range为（1，0）此时InsertOp插入一个长度为2的字符串，则返回的range为（3，0）
文档长度的变化 e.g 例如此时InsertOp插入一个长度为2的字符串，则本次的changeLen则为2
脏区 range 的变化. e.g. 改动产生的脏区（很多业务需要依赖于脏区去做 render 和 layout 这里需要提供准确的值）
Operation 是否有效 e.g. 例如 1. 位置是否超过文档大小，2. 如果传入的是 区间范围，这个范围是否在子文档里，3. 当前修改属性的占位符是否和修改的
Operation 反转后的 mutations 的数组。e.g. 用于 undo redo。
'''

Q：冲突处理以 Mutation 为单位进行处理的，请问有什么常见的 Mutation 呢。
A：Insert Mutation 、Delete Mutation、Modify Mutation、Insert Range Mutation、Delete Range Mutation

Q：什么是原子操作？为啥要将用户的操作转变成原子操作？
A：不可被中断的一个或一系列操作。我们用 mutation 作为原子操作，这样的话的好处是
为什么需要将操作转化为原子操作？
- 一致性：原子操作可以保证每个操作要么完全成功，要么完全失败，不会有部分操作被执行的情况。这对于复杂的操作（例如批量插入或删除）特别重要，避免了在执行过程中发生中断或错误时产生不一致的状态。
- 撤销和重做：原子操作使得撤销和重做变得更简单和可靠，因为每个操作都是一个不可分割的单元。如果我们把一系列操作拆解为原子操作，那么撤销或重做时，就能精确地恢复到上一个操作的状态，而不会中断或出现错误。

Q：数据层的字符和属性是怎么保存的？
A：字符就是可以理解为字符串，代表了文档内部所有的文字和占位符，占位符就比如说有表格的占位符，文本框的占位符，段落换行的占位符等等。
属性就是设置在字符上面的属性，可以有段落属性，文字属性，节属性，文档属性等等。

Q：发生了离线怎么办？
A：当发生离线了，用户产生的 mutation 会临时存储到本地的缓存里面，例如说是 IndexDB 中


环绕排版
Q: 什么是环绕?
A: 文本框就是独立于主文档流的可编辑区域，可以简单的理解为一个div，而环绕的文本框相当于css的中floating，它是可以让文本框脱离文档流，文本框附近的文字可以环绕文本框。

Q：排版是怎么实现的?
A：简单来说，排版就是将数据里面的信息收集归纳，转换成位置和大小信息。

我们首先将数据进行封装，用类似胶水层的方式转换成利于排版层解读的信息，对这些封装的数据我们取名为数据包装节点。
- 将数据从线性结构（当然数据的外在表现是一维的，实际上还是用的一种特殊结构的红黑树进行数据属性查询的）转换成利于排版的树结构，每个节点为一个数据包装节点。树结构举个例子，例如，节内部是段落，段落内部是行，行内部是文本这样。
- 除此之外，从每个数据包装节点的属性中获取位置，大小，内外边距，边框等信息。
接下来就是将 数据包装节点树 转换成 排版盒子树。
- 利用 DFS 遍历数据包转节点树，计算其位置，


Q: 环绕是怎么实现的
A：利用DFS对文档数据节点进行遍历，当遇到环绕节点的占位符的时候，会对其进行收集，如果当前环绕节点已经和之前排好的文本行冲突了，就利用回溯进行回退那些已经排好的文本行，然后再排这个环绕节点，最后再排那些被回退的文本行。其中会有一些简单的计算空间冲突的逻辑。


Canvas渲染层
Q：为什么使用Canvas渲染层？
A：减少渲染层级，传统的React渲染的dom是一层嵌套一层的，举一个极端例子，比如表格嵌套表格，可以递归嵌套很多层，会使得渲染层级变得很深，用canvas只渲染叶子结点会很大的提升效率，平均下来会提升70%左右。
