# 回溯算法 (Backtracking)

## 概念

回溯算法是一种通过探索所有可能的候选解来找出所有解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化抛弃该解，即回溯并且再次尝试。

## 核心思想

1. **选择**：从可选择列表中做一个选择
2. **探索**：进入下一层决策树
3. **撤销**：撤销刚才的选择，回到选择前的状态

## 基本模板

```javascript
function backtrack(路径, 选择列表) {
    if (满足结束条件) {
        result.push([...路径]); // 注意要拷贝
        return;
    }
    
    for (选择 of 选择列表) {
        // 做选择
        路径.push(选择);
        
        // 递归
        backtrack(路径, 新的选择列表);
        
        // 撤销选择
        路径.pop();
    }
}
```

## 目录结构

本目录按照问题类型进行分类，每个子目录包含相关的算法实现和详细说明：

### 📁 [Permutations](./Permutations/) - 排列问题
- **全排列** - 生成所有可能的排列
- **全排列 II** - 包含重复元素的排列去重
- **字符串排列** - 字符串的所有排列
- **下一个排列** - 字典序下一个排列

### 📁 [Combinations](./Combinations/) - 组合问题
- **组合** - 基础组合问题
- **组合总和系列** - 找到和为目标值的组合
- **电话号码字母组合** - 多对多映射组合

### 📁 [Subsets](./Subsets/) - 子集问题
- **子集** - 生成所有可能的子集（幂集）
- **子集 II** - 包含重复元素的子集去重
- **递增子序列** - 有序约束的子集问题
- **最大长度连续子序列** - 无重复字符约束

### 📁 [BoardGames](./BoardGames/) - 棋盘游戏问题
- **N皇后问题** - 在N×N棋盘上放置N个皇后
- **数独求解器** - 填充9×9数独网格
- **数独生成器** - 生成不同难度的数独题目

### 📁 [PathSearch](./PathSearch/) - 路径搜索问题
- **单词搜索** - 在字母网格中搜索单词
- **单词搜索 II** - 使用Trie优化的多单词搜索
- **机器人运动范围** - 带约束的连通性问题
- **黄金矿工** - 最优路径搜索问题
- **不同路径 III** - 必须遍历所有空格的路径计数

### 📁 [StringPartition](./StringPartition/) - 字符串分割问题
- **回文串分割** - 将字符串分割成回文子串
- **回文串分割 II** - 最少分割次数优化
- **复原IP地址** - 固定分割数量的验证
- **单词拆分 II** - 字典匹配分割

## 解题框架

### 1. 确定递归函数的参数
- 当前路径/状态
- 可选择的列表
- 其他必要参数（如目标值、起始位置等）

### 2. 确定终止条件
- 找到一个解
- 无法继续搜索

### 3. 确定选择列表
- 根据题目要求确定每一步可以做什么选择

### 4. 做选择和撤销选择
- 在递归前做选择
- 在递归后撤销选择

## 优化技巧

### 1. 剪枝
在不满足条件时提前返回，避免无效搜索：

```javascript
if (当前路径不可能产生解) {
    return; // 剪枝
}
```

### 2. 去重
对于包含重复元素的问题，需要去重：

```javascript
// 先排序
nums.sort((a, b) => a - b);

// 在同一层级跳过重复元素
if (i > start && nums[i] === nums[i - 1]) {
    continue;
}
```

### 3. 状态压缩
使用位运算等技巧减少状态空间。

## 时间复杂度分析

回溯算法的时间复杂度通常很高，因为需要遍历所有可能的解：
- **排列问题**：O(n! × n)
- **组合问题**：O(2^n × n)
- **子集问题**：O(2^n × n)
- **棋盘问题**：O(N^N) 到 O(N!)
- **路径搜索**：O(4^(M×N))

## 学习路径建议

1. **基础入门**：从排列、组合、子集问题开始
2. **进阶练习**：棋盘游戏问题，理解约束处理
3. **实际应用**：路径搜索和字符串分割问题
4. **优化提升**：学习各种剪枝和优化技巧

## 总结

回溯算法的关键是：
1. 明确选择和撤销的过程
2. 正确设置终止条件
3. 合理剪枝提高效率
4. 处理重复元素的去重逻辑

掌握了回溯的基本模板和各种问题类型，就能解决大部分相关问题！
