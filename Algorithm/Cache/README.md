# 缓存替换算法总结

## 1. LRU (Least Recently Used)
- **原理**：淘汰最久未使用的数据
- **实现**：双向链表 + 哈希表
- **特点**：
  - 时间复杂度：O(1)
  - 适合最近访问的数据未来被访问的概率更大的场景
- **应用**：
  - 浏览器缓存
  - 数据库缓存
  - 操作系统页面置换

## 2. LFU (Least Frequently Used)
- **原理**：淘汰访问频率最低的数据
- **实现**：哈希表 + 频率表
- **特点**：
  - 时间复杂度：O(1)
  - 考虑了访问频率
  - 对突发性的批量访问不友好
- **应用**：
  - CDN缓存
  - 数据库缓存

## 3. FIFO (First In First Out)
- **原理**：淘汰最先进入的数据
- **实现**：队列
- **特点**：
  - 实现简单
  - 不考虑数据的访问情况
- **应用**：
  - 简单的缓冲区管理
  - 消息队列

## 4. Clock (时钟置换算法)
- **原理**：LRU的近似实现，使用循环链表
- **实现**：循环链表 + 使用位
- **特点**：
  - 性能好
  - 实现相对简单
- **应用**：
  - 操作系统页面置换

## 5. ARC (Adaptive Replacement Cache)
- **原理**：结合LRU和LFU的优点
- **实现**：两个LRU列表
- **特点**：
  - 自适应调整
  - 性能优于LRU和LFU
- **应用**：
  - IBM存储系统
  - ZFS文件系统

## 6. 2Q (Two Queue)
- **原理**：使用两个队列，一个用于新数据，一个用于频繁访问的数据
- **实现**：两个FIFO队列 + 一个LRU队列
- **特点**：
  - 比LRU性能好
  - 实现相对复杂
- **应用**：
  - 数据库缓存

## 7. MRU (Most Recently Used)
- **原理**：淘汰最近使用的数据
- **实现**：类似LRU
- **特点**：
  - 适合特定场景
  - 实现简单
- **应用**：
  - 特定的IO模式
  - 随机访问较多的场景

## 面试常考点

### 1. LRU vs LFU
```javascript
// LRU示例
访问顺序：1, 2, 1, 3, 2, 4, 1
缓存大小：3
过程：[1] -> [1,2] -> [1,2] -> [1,2,3] -> [1,2,3] -> [2,3,4] -> [3,4,1]

// LFU示例
访问顺序：1, 2, 1, 3, 2, 4, 1
缓存大小：3
过程：[1] -> [1,2] -> [1,2] -> [1,2,3] -> [1,2,3] -> [1,2,3] -> [1,2,3]
```

### 2. 实现要点
1. **数据结构选择**：
   - 哈希表：O(1)查找
   - 双向链表：O(1)删除
   - 堆：频率排序

2. **边界情况处理**：
   - 缓存满了的处理
   - 频率相同时的处理
   - 缓存为空的处理

3. **性能优化**：
   - 时间复杂度
   - 空间复杂度
   - 并发处理

### 3. 实际应用场景
1. **浏览器缓存**：
   - LRU：最近访问的页面
   - LFU：频繁访问的资源

2. **数据库缓存**：
   - LRU：查询缓存
   - 2Q：Buffer Pool

3. **操作系统**：
   - Clock：页面置换
   - ARC：文件系统缓存

### 4. 进阶优化
1. **并发处理**：
   - 读写锁
   - CAS操作

2. **分布式缓存**：
   - 一致性哈希
   - 副本管理

3. **自适应策略**：
   - 动态调整大小
   - 智能预加载
