# 二叉树遍历应用题集合

## 🎯 项目概述

本项目系统性地整理了二叉树三种遍历方式的应用题，帮助深入理解每种遍历方式的特点和适用场景。

## 📁 目录结构

```
Algorithm/Tree/order/
├── README.md                    # 总体介绍
├── Order.md                     # 遍历性质详细总结
├── preorder/                    # 前序遍历应用
│   ├── README.md               # 前序遍历说明
│   ├── cloneTree.js            # 树的克隆
│   └── serialize.js            # 树的序列化
├── inorder/                     # 中序遍历应用
│   ├── README.md               # 中序遍历说明
│   ├── validateBST.js          # 验证二叉搜索树
│   └── kthSmallest.js          # BST中第K小元素
└── postorder/                   # 后序遍历应用
    ├── README.md               # 后序遍历说明
    ├── maxDepth.js             # 计算树的最大深度
    └── isBalanced.js           # 判断平衡二叉树
```

## 🔥 三种遍历方式对比

| 遍历方式 | 访问顺序 | 根节点位置 | 主要特点 | 典型应用 |
|---------|---------|-----------|---------|---------|
| **前序** | 根→左→右 | 第一个 | 自顶向下 | 复制、序列化、构建 |
| **中序** | 左→根→右 | 中间 | BST有序 | 排序、验证、分治 |
| **后序** | 左→右→根 | 最后一个 | 自底向上 | 计算、删除、验证 |

## 🎯 遍历选择策略

### 🌟 前序遍历 - 自顶向下
**何时使用：**
- ✅ 需要先处理根节点的场景
- ✅ 复制、序列化树结构
- ✅ 构建新的数据结构
- ✅ 文件系统遍历

**核心思想：** 先确定根，再处理子树

### 🌟 中序遍历 - 有序访问
**何时使用：**
- ✅ 二叉搜索树(BST)相关操作
- ✅ 需要有序访问节点
- ✅ 构建树时作为分割依据
- ✅ 范围查询和修剪

**核心思想：** 利用BST的有序性质

### 🌟 后序遍历 - 自底向上
**何时使用：**
- ✅ 需要先处理子节点的场景
- ✅ 计算树的属性（高度、大小等）
- ✅ 删除、释放资源
- ✅ 验证树的性质

**核心思想：** 子树信息向根节点汇聚

## 📚 应用题分类

### 前序遍历应用
1. **树的复制和序列化**
   - [树的克隆](./preorder/cloneTree.js) - 深度复制整棵二叉树
   - [二叉树序列化](./preorder/serialize.js) - 将树转换为字符串并反序列化

2. **树结构分析**
   - 打印树结构、计算深度、路径总和

3. **表达式树处理**
   - 前缀表达式求值、构建表达式树

### 中序遍历应用
1. **BST操作**
   - [验证BST](./inorder/validateBST.js) - 检查二叉树是否为有效BST
   - [第K小元素](./inorder/kthSmallest.js) - 找到BST中第K小的元素

2. **树的分析和修复**
   - 恢复BST、BST中的众数、两数之和

3. **构建和重建**
   - 有序数组转BST、前序+中序构建树

### 后序遍历应用
1. **树的属性计算**
   - [计算树的高度](./postorder/maxDepth.js) - 自底向上计算最大深度
   - [判断平衡二叉树](./postorder/isBalanced.js) - 检查是否为平衡二叉树

2. **树的验证和判断**
   - 判断完全二叉树、相同的树、对称二叉树

3. **路径和求和问题**
   - 路径总和、最大路径和、路径数统计

## 🔥 核心模板代码

### 前序遍历模板
```javascript
function preorderTraversal(root) {
    if (!root) return;
    
    // 1. 处理当前节点（根）
    process(root);
    
    // 2. 递归处理左子树
    preorderTraversal(root.left);
    
    // 3. 递归处理右子树
    preorderTraversal(root.right);
}
```

### 中序遍历模板
```javascript
function inorderTraversal(root) {
    if (!root) return;
    
    // 1. 递归处理左子树
    inorderTraversal(root.left);
    
    // 2. 处理当前节点（根）
    process(root);
    
    // 3. 递归处理右子树
    inorderTraversal(root.right);
}
```

### 后序遍历模板
```javascript
function postorderTraversal(root) {
    if (!root) return;
    
    // 1. 递归处理左子树
    postorderTraversal(root.left);
    
    // 2. 递归处理右子树
    postorderTraversal(root.right);
    
    // 3. 处理当前节点（根）
    process(root);
}
```

## 💡 学习建议

### 🎯 记忆要点
1. **遍历顺序**：根据"根节点"的访问位置记忆
   - 前序：**根**左右
   - 中序：左**根**右
   - 后序：左右**根**

2. **应用场景**：
   - 前序：**构建**优先（复制、序列化）
   - 中序：**有序**优先（BST操作）
   - 后序：**计算**优先（属性、验证）

3. **构建二叉树**：
   - 前序+中序：从前往后，先左后右
   - 后序+中序：从后往前，先右后左

### 🚀 学习路径
1. **理解基础**：先掌握三种遍历的定义和递归实现
2. **分析特点**：理解每种遍历的独特性质
3. **应用练习**：通过具体题目加深理解
4. **模式识别**：学会根据题目特点选择合适的遍历方式

## 🎯 面试重点

### 必须掌握的内容
- ✅ 三种遍历的定义和实现
- ✅ BST中序遍历的有序性
- ✅ 前序/后序+中序构建树的方法
- ✅ 后序遍历计算树属性的模式
- ✅ 根据题目特点选择合适的遍历方式

### 常考题型
1. **遍历实现**：递归和迭代两种方式
2. **树的构建**：根据遍历序列重建树
3. **BST操作**：验证、查找、修改
4. **树的属性**：高度、平衡性、对称性
5. **路径问题**：路径和、最长路径

## 🔗 相关资源

- [Order.md](./Order.md) - 详细的遍历性质总结
- [前序遍历应用](./preorder/) - 自顶向下的算法集合
- [中序遍历应用](./inorder/) - BST和有序访问的算法集合
- [后序遍历应用](./postorder/) - 自底向上的算法集合

---

**记住：理解原理比死记硬背更重要！** 掌握了核心思想，代码自然就会写了。
