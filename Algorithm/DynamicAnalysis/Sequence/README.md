# 序列类动态规划问题

## 什么是子序列？

### 子序列 vs 子串
1. **子序列(Subsequence)**：
   - 可以从原序列中删除某些元素（也可以不删除）得到
   - 元素顺序必须保持不变
   - 元素可以不连续
   - 例如："abc" 的子序列有：["a", "b", "c", "ab", "ac", "bc", "abc"]

2. **子串(Substring)**：
   - 必须是原序列中连续的一段
   - 例如："abc" 的子串只有：["a", "b", "c", "ab", "bc", "abc"]

### 示例
原序列：[1,2,3,4]
- 子序列：[1,3], [2,4], [1,2,3] 等都是合法的子序列
- 子串：只有[1,2], [2,3], [3,4], [1,2,3], [2,3,4], [1,2,3,4]等连续的序列才是子串

## 为什么要用动态规划？

### 1. 重叠子问题
在处理子序列问题时，通常会遇到大量重叠的子问题：

```javascript
// 例如在LIS中：
// 计算以nums[4]结尾的LIS时，需要查看nums[0]~nums[3]结尾的LIS
// 计算以nums[5]结尾的LIS时，也需要查看nums[0]~nums[4]结尾的LIS
// 这里就有大量重复计算
```

### 2. 最优子结构
子序列问题通常具有最优子结构特性：

```javascript
// 例如在LCS中：
// 如果两个序列的最后一个字符相同：
LCS("abcd", "abed") = LCS("abc", "abe") + "d"

// 如果不同：
LCS("abcd", "abe") = max(LCS("abc", "abe"), LCS("abcd", "ab"))
```

### 3. 无后效性
当前状态一旦确定，就不会受到后续决策的影响：

```javascript
// 在LIS中：
// dp[i]表示以nums[i]结尾的最长递增子序列长度
// 一旦dp[i]确定，后面的元素无法改变这个值
```

## 经典问题解析

### 1. 最长递增子序列(LIS)

#### 为什么用DP？
1. **暴力解法的问题**：
   - 需要考虑所有可能的子序列
   - 时间复杂度是O(2^n)
   - 有大量重复计算

2. **DP的优势**：
   - 状态定义清晰：dp[i]表示以nums[i]结尾的LIS长度
   - 避免重复计算：每个位置只计算一次
   - 时间复杂度降到O(n^2)

#### 状态转移方程
```javascript
// 对于每个位置i
dp[i] = max(dp[j] + 1) for all j < i and nums[j] < nums[i]
```

### 2. 最长公共子序列(LCS)

#### 为什么用DP？
1. **暴力解法的问题**：
   - 需要考虑所有可能的子序列组合
   - 时间复杂度是O(2^(m+n))
   - 存在大量重复比较

2. **DP的优势**：
   - 状态定义直观：dp[i][j]表示text1前i个字符和text2前j个字符的LCS长度
   - 状态转移清晰
   - 时间复杂度降到O(mn)

#### 状态转移方程
```javascript
if (text1[i-1] === text2[j-1]) {
    dp[i][j] = dp[i-1][j-1] + 1;
} else {
    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
}
```

## 常见变种

### 1. 最长递增子序列变种
- 最长递减子序列
- 最长交替子序列
- 最长等差子序列
- 最长上升子序列的个数

### 2. 最长公共子序列变种
- 最长公共子串
- 最短公共超序列
- 编辑距离
- 不同的子序列个数

## 循环设计差异：为什么都只用两个循环？

### 单字符串 vs 双字符串问题

#### 最长递增子序列（LIS）——单字符串
```javascript
for (let i = 1; i < n; i++) {        // 外层：当前位置
    for (let j = 0; j < i; j++) {    // 内层：查找所有可能的前序位置
        if (nums[j] < nums[i]) {     // 只比较一个字符串内部的值
            dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }
}
```
- **一个字符串**：nums
- **一维DP**：dp[i] 表示以nums[i]结尾的LIS长度
- **双层循环**：i遍历当前位置，j遍历所有可能的前置位置

#### 最长公共子序列（LCS）——双字符串
```javascript
for (let i = 1; i <= m; i++) {       // 外层：第一个字符串的位置
    for (let j = 1; j <= n; j++) {   // 内层：第二个字符串的位置
        if (text1[i-1] === text2[j-1]) {  // 比较两个字符串
            dp[i][j] = dp[i-1][j-1] + 1;
        } else {
            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
        }
    }
}
```
- **两个字符串**：text1 和 text2
- **二维DP**：dp[i][j] 表示text1前i个字符和text2前j个字符的LCS长度
- **双层循环**：i遍历text1，j遍历text2，遍历的是字符对组合

### 关键区别理解

1. **状态空间不同**：
   - LIS：状态空间是 `n`（一个字符串的长度）
   - LCS：状态空间是 `m × n`（两个字符串长度的乘积）

2. **循环含义不同**：
   - LIS：内层循环是在**同一个字符串内部**查找所有可能的前置位置
   - LCS：内层循环是在**两个字符串之间**遍历所有可能的字符比较

3. **状态转移方式**：
   ```javascript
   // LIS：当前元素与字符串内所有前置位置比较
   dp[i] ← dp[j] (j < i, nums[j] < nums[i])
   
   // LCS：两个字符串的当前位置比较
   dp[i][j] ← dp[i-1][j-1] | dp[i-1][j] | dp[i][j-1]
   ```

4. **复杂度对比**：
   ```javascript
   // LIS: O(n²) - 每个位置要检查前面所有位置
   for (i = 0; i < n; i++)
       for (j = 0; j < i; j++)  // j只到i
   
   // LCS: O(mn) - 遍历所有字符对
   for (i = 1; i <= m; i++)
       for (j = 1; j <= n; j++)  // j到n
   ```

### 为什么都是双层循环？

1. **LIS的双层循环**：
   - 外层i：当前考虑的位置
   - 内层j：在前面所有位置中寻找能接的序列

2. **LCS的双层循环**：
   - 外层i：第一个字符串当前考虑的位置
   - 内层j：第二个字符串当前考虑的位置

虽然都有两层循环，但它们的**目的和含义完全不同**：

```javascript
// LIS：在序列内部寻找
positions: [0,1,2,3,4,5]
           ↑     ↑  ↑
          j=1   i=3 j=5
          比较是否nums[1] < nums[3] < nums[5]

// LCS：在两个序列间寻找
text1: ['a','b','c','d']
text2: ['a','c','e']
       ↑      ↑  ↑
      i=0,j=0 i=2,j=1
       比较text1[0]和text2[0]是否相等
```

### 2. 初始化
- 考虑边界情况
- 通常dp[0]或dp[1]需要特殊初始化

### 3. 状态转移
- 找到状态之间的关系
- 通常需要考虑"选"或"不选"当前元素

### 4. 空间优化
- 很多序列DP问题可以优化空间
- 通常可以用滚动数组或一维数组代替二维数组

## 注意事项

1. **子序列vs子串**：
   - 理解问题是要求子序列还是子串
   - 子串必须连续，子序列可以不连续

2. **状态定义**：
   - dp[i]通常有两种定义方式：
     - 以第i个元素结尾
     - 考虑前i个元素

3. **遍历顺序**：
   - 确保计算dp[i]时，依赖的状态都已经计算出来
   - 通常是从左到右遍历
