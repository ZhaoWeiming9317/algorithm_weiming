# 动态规划 vs 贪心算法

## 1. 核心区别

### 动态规划 (Dynamic Programming)
- **策略**：考虑所有可能的选择，选择最优的
- **特点**：自底向上，从子问题开始构建
- **保证**：保证找到全局最优解
- **复杂度**：通常较高，需要存储中间结果

### 贪心算法 (Greedy Algorithm)
- **策略**：每步都做局部最优选择
- **特点**：自顶向下，从当前状态开始选择
- **保证**：不保证全局最优，但通常接近最优
- **复杂度**：通常较低，不需要存储中间结果

## 2. 详细对比

| 特征 | 动态规划 | 贪心算法 |
|------|----------|----------|
| **选择策略** | 考虑所有可能选择 | 每步选择局部最优 |
| **计算方向** | 自底向上 | 自顶向下 |
| **存储需求** | 需要存储中间结果 | 通常不需要额外存储 |
| **时间复杂度** | 通常较高 | 通常较低 |
| **空间复杂度** | 通常较高 | 通常较低 |
| **最优性** | 保证全局最优 | 不保证全局最优 |
| **适用场景** | 有重叠子问题 | 有贪心选择性质 |

## 3. 选择标准

### 使用动态规划的情况
1. **有重叠子问题**：子问题会被重复计算
2. **需要全局最优**：必须找到最优解
3. **状态转移复杂**：当前状态依赖多个之前的状态
4. **问题规模较大**：需要系统性的解决方案

**典型问题**：
- 最长公共子序列
- 0-1背包问题
- 编辑距离
- 最长递增子序列

### 使用贪心算法的情况
1. **有贪心选择性质**：局部最优能导致全局最优
2. **问题规模较大**：需要快速解决方案
3. **近似解可接受**：不需要严格的最优解
4. **实时性要求高**：需要快速响应

**典型问题**：
- 活动选择问题
- 最小生成树
- 最短路径（Dijkstra）
- 任务调度问题

## 4. 实际应用场景

### 动态规划适用场景
```javascript
// 1. 需要全局最优解
// 2. 有重叠子问题
// 3. 状态转移复杂

// 例子：0-1背包问题
function knapsack(weights, values, capacity) {
    const n = weights.length;
    const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));
    
    for (let i = 1; i <= n; i++) {
        for (let w = 1; w <= capacity; w++) {
            if (weights[i-1] <= w) {
                dp[i][w] = Math.max(
                    dp[i-1][w],
                    dp[i-1][w - weights[i-1]] + values[i-1]
                );
            } else {
                dp[i][w] = dp[i-1][w];
            }
        }
    }
    
    return dp[n][capacity];
}
```

### 贪心算法适用场景
```javascript
// 1. 局部最优能导致全局最优
// 2. 需要快速解决方案
// 3. 近似解可接受

// 例子：活动选择问题
function activitySelection(activities) {
    activities.sort((a, b) => a.end - b.end);
    
    const selected = [activities[0]];
    let lastEndTime = activities[0].end;
    
    for (let i = 1; i < activities.length; i++) {
        if (activities[i].start >= lastEndTime) {
            selected.push(activities[i]);
            lastEndTime = activities[i].end;
        }
    }
    
    return selected;
}
```

## 5. 混合使用策略

### 分层解决
1. **顶层**：使用贪心算法快速筛选
2. **底层**：使用动态规划精确求解

### 预处理优化
1. **预处理**：使用贪心算法预处理数据
2. **主算法**：使用动态规划求解核心问题

## 6. 决策流程

```
问题分析
    ↓
是否有贪心选择性质？
    ↓ 是                    ↓ 否
贪心算法                动态规划
    ↓                    ↓
验证局部最优          验证最优子结构
    ↓                    ↓
实现算法              实现算法
    ↓                    ↓
测试验证              测试验证
```

## 7. 总结

### 动态规划
- **优势**：保证最优解，适用面广
- **劣势**：复杂度高，实现复杂
- **适用**：需要精确解的问题

### 贪心算法
- **优势**：实现简单，效率高
- **劣势**：不保证最优解
- **适用**：可以接受近似解的问题

### 选择建议
1. **优先考虑贪心**：如果问题有明显的贪心选择性质
2. **必要时使用DP**：如果贪心策略失效或需要精确解
3. **混合使用**：复杂问题可以分层使用不同策略
