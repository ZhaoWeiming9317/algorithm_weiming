# 单调队列 (Monotonic Queue)

## 1. 基本概念

单调队列是一种特殊的队列，它维护队列中元素的单调性（递增或递减）。

## 2. 核心思想

- **单调递减队列**：队首元素最大，队尾元素最小
- **单调递增队列**：队首元素最小，队尾元素最大
- **维护原则**：新元素入队时，移除所有违反单调性的元素

## 3. 滑动窗口最大值

### 3.1 算法步骤

1. **初始化**：创建双端队列存储数组索引
2. **移除过期元素**：删除窗口外的元素索引
3. **维护单调性**：移除所有小于当前元素的元素
4. **添加当前元素**：将当前元素索引加入队列
5. **记录结果**：队首元素就是当前窗口的最大值

### 3.2 时间复杂度分析

- **时间复杂度**：O(n) - 每个元素最多入队和出队一次
- **空间复杂度**：O(k) - 队列最多存储 k 个元素

## 4. 关键代码

```javascript
function maxSlidingWindow(nums, k) {
  const result = [];
  const deque = []; // 存储索引，维护递减序列
  
  for (let i = 0; i < nums.length; i++) {
    // 1. 移除窗口外的元素
    while (deque.length > 0 && deque[0] <= i - k) {
      deque.shift();
    }
    
    // 2. 移除所有小于当前元素的元素
    while (deque.length > 0 && nums[deque[deque.length - 1]] <= nums[i]) {
      deque.pop();
    }
    
    // 3. 添加当前元素索引
    deque.push(i);
    
    // 4. 记录最大值
    if (i >= k - 1) {
      result.push(nums[deque[0]]);
    }
  }
  
  return result;
}
```

## 5. 面试要点

### 5.1 核心理解
- 为什么存储索引而不是值？
- 如何保证队首是最大值？
- 如何处理窗口滑动？

### 5.2 常见问题
1. **为什么移除小于当前元素的元素？**
   - 因为它们不可能成为后续窗口的最大值

2. **为什么从队尾移除？**
   - 保持队列的单调性

3. **如何优化空间复杂度？**
   - 只存储必要的元素索引

## 6. 扩展应用

- 滑动窗口最小值
- 下一个更大元素
- 柱状图中最大的矩形
- 接雨水问题

## 7. 记忆技巧

1. **单调队列三步骤**：
   - 移除过期元素
   - 维护单调性
   - 添加新元素

2. **核心思想**：
   - 队列中只保留"有用"的元素
   - 队首始终是当前窗口的最值

3. **实现要点**：
   - 使用双端队列
   - 存储索引而非值
   - 及时移除过期元素
