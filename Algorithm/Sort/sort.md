1. 冒泡排序 (Bubble Sort)
时间复杂度：O(n²)
空间复杂度：O(1)
稳定性：稳定
特点：简单但效率较低
2. 选择排序 (Selection Sort)
时间复杂度：O(n²)
空间复杂度：O(1)
稳定性：不稳定
特点：交换次数少
3. 插入排序 (Insertion Sort)
时间复杂度：O(n²)，最好情况 O(n)
空间复杂度：O(1)
稳定性：稳定
特点：对于小规模数据或基本有序的数据效率较高
4. 快速排序 (Quick Sort)
时间复杂度：平均 O(nlogn)，最坏 O(n²)
空间复杂度：O(logn)
稳定性：不稳定
特点：实际应用中最常用的排序算法之一
5. 归并排序 (Merge Sort)
时间复杂度：O(nlogn)
空间复杂度：O(n)
稳定性：稳定
特点：稳定的排序算法，适合大数据量
6. 堆排序 (Heap Sort)
时间复杂度：O(nlogn)
空间复杂度：O(1)
稳定性：不稳定
特点：适合大数据量，空间效率高
7. 希尔排序 (Shell Sort)
时间复杂度：平均 O(nlogn)，最坏 O(n²)
空间复杂度：O(1)
稳定性：不稳定
特点：插入排序的改进版本
8. 计数排序 (Counting Sort)
时间复杂度：O(n+k)，k是数据范围
空间复杂度：O(k)
稳定性：稳定
特点：适用于已知范围的整数排序
9. 基数排序 (Radix Sort)
时间复杂度：O(d(n+k))，d是位数，k是基数
空间复杂度：O(n+k)
稳定性：稳定
特点：适用于整数或字符串排序
10. 桶排序 (Bucket Sort)
时间复杂度：平均 O(n+k)，最坏 O(n²)
空间复杂度：O(n+k)
稳定性：稳定
特点：适用于均匀分布的数据


Q: 既然堆排序空间复杂度低，为啥要用快速排序呢
A: 
1. 缓存友好性
快速排序：具有很好的局部性，连续访问内存，对CPU缓存更友好
堆排序：由于需要在树结构中跳跃访问节点，缓存命中率较低
2. 实际运行速度
快速排序：
平均情况下常数因子更小
内循环更简单，指令更少
数据移动次数通常更少
堆排序：
需要频繁进行上浮/下沉操作
比较次数往往多于快速排序
内循环操作更复杂

Q：什么是内循环
A: 内循环的定义。内循环（Inner Loop）是指在程序执行过程中最频繁执行的代码部分，通常是嵌套循环中最里层的循环。


## 选择排序 插入排序
1. 操作方式：
插入排序：在已排序区间中找插入位置，可能需要移动多个元素
选择排序：在未排序区间中找最小值，只需要一次交换
2. 稳定性：
插入排序是稳定的，因为相等元素的相对位置不会改变
选择排序是不稳定的，因为交换可能改变相等元素的相对位置
3. 性能特点：
插入排序：对于基本有序的数据非常高效，最好情况可达到O(n)
选择排序：无论输入如何都需要O(n²)，但交换次数较少
