/**
 * 单调递增栈模板
 * 
 * 核心原理：维护一个从栈底到栈顶单调递增的栈
 * 
 * 为什么能找到"第一个更小元素"？
 * 
 * 1. 栈的性质：栈顶元素是最近加入的，也是当前最大的元素
 * 2. 弹出时机：当遇到更小的元素时，说明栈顶元素找到了它右边第一个更小的元素
 * 3. 单调性保证：由于栈是单调递增的，被弹出的元素一定比当前元素大
 * 
 * 举例说明：数组 [3, 1, 4, 2]
 * i=0: arr[0]=3, stack=[0]                    // 3入栈
 * i=1: arr[1]=1 <= arr[0]=3, 弹出index=0     // 1是3右边第一个更小的元素
 *      stack=[1]                              // 1入栈
 * i=2: arr[2]=4 > arr[1]=1, 不弹出           // 4比1大，维持单调性
 *      stack=[1,2]                           // 4入栈
 * i=3: arr[3]=2 <= arr[2]=4, 弹出index=2     // 2是4右边第一个更小的元素
 *      arr[3]=2 > arr[1]=1, 不再弹出          // 2比1大，停止弹出
 *      stack=[1,3]                           // 2入栈
 * 
 * 关键理解：
 * - 被弹出的元素找到了它的"下一个更小元素"
 * - 距离 i - index 就是两个位置之间的跨度
 * - 单调性确保了这是"第一个"更小的元素
 */
export const monotonicStackIncrease = (arr) => {
    const stack = []; // 单调递增栈，存储数组下标
    const result = []; // 存储结果

    for (let i = 0; i < arr.length; i++) {
        // 维护单调递增性：当前元素 <= 栈顶元素时，弹出栈顶
        // 注意：<= 还是 < 取决于具体问题的语义要求！
        // 选择依据：
        // - 如果问题要求"下一个更小元素"（严格小于）：使用 <
        // - 如果问题要求"下一个小于等于元素"（包含相等）：使用 <=
        // - 柱状图最大矩形：使用 < ，因为相等高度可以合并成更大矩形
        while (
            stack.length > 0 && 
            arr[i] <= arr[stack[stack.length - 1]]  // 小于等于
        ) {
            const index = stack.pop(); // 弹出的元素找到了它的"下一个更小元素"

            // 处理被弹出的元素
            // index: 被弹出元素的位置
            // i: 当前元素的位置（也是index右边第一个更小元素的位置）
            // i - index: 两个位置之间的距离/跨度

            // 根据具体问题进行处理，例如：
            // result[index] = i - index;  // 记录距离
            // result[index] = i;          // 记录位置
            // result[index] = arr[i];     // 记录值
        }

        stack.push(i); // 当前元素入栈，维护单调递增性
    }

    return result;
}

/**
 * 单调递减栈模板
 * 
 * 核心原理：维护一个从栈底到栈顶单调递减的栈
 * 
 * 为什么能找到"第一个更大元素"？
 * 
 * 1. 栈的性质：栈顶元素是最近加入的，也是当前最小的元素
 * 2. 弹出时机：当遇到更大的元素时，说明栈顶元素找到了它右边第一个更大的元素
 * 3. 单调性保证：由于栈是单调递减的，被弹出的元素一定比当前元素小
 * 
 * 举例说明：数组 [1, 3, 2, 4]
 * i=0: arr[0]=1, stack=[0]                    // 1入栈
 * i=1: arr[1]=3 > arr[0]=1, 弹出index=0      // 3是1右边第一个更大的元素
 *      stack=[1]                              // 3入栈
 * i=2: arr[2]=2 < arr[1]=3, 不弹出           // 2比3小，维持单调性
 *      stack=[1,2]                           // 2入栈
 * i=3: arr[3]=4 > arr[2]=2, 弹出index=2      // 4是2右边第一个更大的元素
 *      arr[3]=4 > arr[1]=3, 继续弹出index=1   // 4是3右边第一个更大的元素
 *      stack=[3]                             // 4入栈
 * 
 * 应用场景：
 * - 每日温度问题：找下一个更高温度
 * - 下一个更大元素
 * - 股票价格跨度
 */
export const monotonicStackDecrease = (arr) => {
    const stack = []; // 单调递减栈，存储数组下标
    const result = []; // 存储结果
    
    for (let i = 0; i < arr.length; i++) {
        // 维护单调递减性：当前元素 > 栈顶元素时，弹出栈顶
        // 注意：> 还是 >= 取决于具体问题的语义要求！
        // 选择依据：
        // - 每日温度：使用 > ，因为需要"更高"温度（严格大于）
        // - 下一个更大元素：使用 > ，因为要求"更大"（严格大于）
        // - 如果问题允许相等也算"找到"：使用 >=
        while (
            stack.length > 0 && 
            arr[i] > arr[stack[stack.length - 1]]  // 严格大于
        ) {
            const index = stack.pop(); // 弹出的元素找到了它的"下一个更大元素"
            
            // 处理被弹出的元素
            // index: 被弹出元素的位置
            // i: 当前元素的位置（也是index右边第一个更大元素的位置）
            // i - index: 两个位置之间的距离/跨度
            
            // 根据具体问题进行处理，例如：
            // result[index] = i - index;  // 记录距离（每日温度）
            // result[index] = i;          // 记录位置
            // result[index] = arr[i];     // 记录值（下一个更大元素）
        }
        
        stack.push(i); // 当前元素入栈，维护单调递减性
    }
    
    return result;
}