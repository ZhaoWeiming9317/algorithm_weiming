# 排列问题 (Permutations)

## 概述

排列问题是回溯算法的经典应用之一。排列是指从n个不同元素中取出m个元素，按照一定的顺序排成一列。

## 核心特点

- **顺序重要**：[1,2,3] 和 [3,2,1] 是不同的排列
- **元素不重复使用**：每个元素在一个排列中只能出现一次
- **全排列**：当m=n时，称为全排列

## 基本思路

1. **选择**：从剩余可选元素中选择一个
2. **递归**：对剩余元素继续排列
3. **回溯**：撤销选择，尝试其他可能

## 模板代码

```javascript
function permute(nums) {
    const result = [];
    const path = [];
    const used = new Array(nums.length).fill(false);
    
    function backtrack() {
        // 终止条件
        if (path.length === nums.length) {
            result.push([...path]);
            return;
        }
        
        // 选择列表
        for (let i = 0; i < nums.length; i++) {
            if (used[i]) continue; // 跳过已使用的元素
            
            // 做选择
            path.push(nums[i]);
            used[i] = true;
            
            // 递归
            backtrack();
            
            // 撤销选择
            path.pop();
            used[i] = false;
        }
    }
    
    backtrack();
    return result;
}
```

## 去重策略

对于包含重复元素的排列问题：

1. **先排序**：将相同元素放在一起
2. **跳过重复**：在同一层级跳过重复元素
3. **保证顺序**：相同元素按原数组顺序使用

```javascript
// 去重条件
if (i > 0 && nums[i] === nums[i - 1] && !used[i - 1]) {
    continue; // 跳过重复元素
}
```

## 问题列表

### 1. 全排列 (Permutations)
- **难度**：中等
- **特点**：无重复元素的基础排列问题

### 2. 全排列 II (Permutations II)
- **难度**：中等
- **特点**：包含重复元素，需要去重

### 3. 字符串的排列
- **难度**：中等
- **特点**：字符串版本的排列问题

### 4. 下一个排列 (Next Permutation)
- **难度**：中等
- **特点**：字典序的下一个排列，非回溯解法

## 时间复杂度

- **全排列**：O(n! × n) - n!种排列，每种需要O(n)时间复制
- **空间复杂度**：O(n) - 递归栈和辅助数组

## 应用场景

1. **任务调度**：不同任务的执行顺序
2. **路径规划**：访问所有地点的不同路线
3. **密码破解**：尝试所有可能的排列组合
4. **游戏AI**：棋类游戏的走法枚举

## 优化技巧

1. **剪枝**：提前判断不可能的情况
2. **去重**：避免生成重复的排列
3. **迭代优化**：某些情况下可以用迭代代替递归

掌握排列问题的解法，是理解回溯算法的重要基础！
