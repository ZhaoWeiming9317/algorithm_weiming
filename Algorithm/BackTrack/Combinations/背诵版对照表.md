# 回溯算法：组合 vs 排列 vs 电话号码（背诵版）

## 🎯 核心区别表（必背）

| 特性           | 组合 (Combination)      | 排列 (Permutation)      | 电话号码字母组合         |
|:--------------|:-----------------------|:-----------------------|:----------------------|
| **考虑顺序**    | ❌ 不考虑                | ✅ 考虑                 | ✅ 考虑                |
| **参数**       | `start`                | 无                      | `index`               |
| **循环起点**    | `i = start`            | `i = 0`                | 遍历字母               |
| **递归调用**    | `(i+1)` 或 `(i)`       | `()`                   | `(index+1)`           |
| **防重复机制**  | `start` 参数            | `used[]` 数组           | 无需防重               |
| **去重条件**    | `i > start`            | `!used[i-1]`           | 无重复元素             |
| **示例**       | [1,2] = [2,1]          | [1,2] ≠ [2,1]          | "23" → "ad","ae"...   |

---

## 🔥 代码模板对比（必背）

### 1️⃣ 组合模板
```javascript
function combine(n, k) {
    const result = [], path = [];
    
    function backtrack(start) {           // ✅ 有 start
        if (path.length === k) {
            result.push([...path]);
            return;
        }
        
        for (let i = start; i <= n; i++) { // ✅ 从 start 开始
            path.push(i);
            backtrack(i + 1);              // ✅ i+1（不可重复）或 i（可重复）
            path.pop();
        }
    }
    
    backtrack(1);
    return result;
}
```

### 2️⃣ 排列模板
```javascript
function permute(nums) {
    const result = [], path = [];
    const used = new Array(nums.length).fill(false); // ✅ used 数组
    
    function backtrack() {                // ✅ 无 start
        if (path.length === nums.length) {
            result.push([...path]);
            return;
        }
        
        for (let i = 0; i < nums.length; i++) { // ✅ 从 0 开始
            if (used[i]) continue;
            
            path.push(nums[i]);
            used[i] = true;
            backtrack();                  // ✅ 无参数
            path.pop();
            used[i] = false;
        }
    }
    
    backtrack();
    return result;
}
```

### 3️⃣ 电话号码模板
```javascript
function letterCombinations(digits) {
    if (!digits) return [];
    
    const phoneMap = {'2':'abc', '3':'def', ...};
    const result = [], path = [];
    
    function backtrack(index) {           // ✅ index（位置）
        if (index === digits.length) {
            result.push(path.join(''));
            return;
        }
        
        const letters = phoneMap[digits[index]];
        for (let letter of letters) {     // ✅ 遍历字母
            path.push(letter);
            backtrack(index + 1);         // ✅ index+1（下一位）
            path.pop();
        }
    }
    
    backtrack(0);
    return result;
}
```

---

## 💡 去重对比（必背）

| 类型         | 适用场景              | 去重条件                                          | 目的                |
|:------------|:---------------------|:------------------------------------------------|:-------------------|
| **组合去重**  | 输入有重复元素         | `i > start && nums[i] === nums[i-1]`           | 同一层跳过重复       |
| **排列去重**  | 输入有重复元素         | `i > 0 && nums[i] === nums[i-1] && !used[i-1]` | 按顺序使用相同元素   |
| **共同点**    | 都需要**先排序**       | `nums.sort((a, b) => a - b)`                   | 让相同元素相邻       |

---

## 🎨 可视化记忆

### 组合：不走回头路
```
[1,2,3] 选 2 个

    1 ──→ 2 ✅
    1 ──→ 3 ✅
    2 ──→ 3 ✅
    
    2 ──X→ 1 ❌ (不能回头)
    3 ──X→ 1 ❌ (不能回头)
    3 ──X→ 2 ❌ (不能回头)

结果: [[1,2], [1,3], [2,3]]  (3个)
```

### 排列：可以回头
```
[1,2,3] 全排列

    1 ──→ 2 ✅
    1 ──→ 3 ✅
    2 ──→ 1 ✅ (可以回头，只要没用过)
    2 ──→ 3 ✅
    3 ──→ 1 ✅
    3 ──→ 2 ✅

结果: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]  (6个)
```

### 电话号码：逐层递进
```
"23"

第0层: 2 → abc
第1层: 3 → def

    a ──→ d,e,f
    b ──→ d,e,f
    c ──→ d,e,f

结果: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]  (9个)
```

---

## ⚡ 快速判断口诀（必背）

1. **看顺序** → 不管顺序是组合，管顺序是排列
2. **看参数** → 有 `start` 是组合，无 `start` 是排列
3. **看递归** → 传 `i+1` 是组合，传 `()` 是排列
4. **看防重** → 用 `start` 是组合，用 `used[]` 是排列

**特殊：电话号码**
- 参数是 `index`（处理第几个数字）
- 递归是 `index+1`（移动到下一个数字）
- 不是防重复，是**纵向递进**！

---

## 📊 结果数量对比

```
从 [1,2,3] 中选 2 个：

组合: C(3,2) = 3 个
    ↓
[1,2], [1,3], [2,3]

排列: A(3,2) = 6 个
    ↓
[1,2], [1,3], [2,1], [2,3], [3,1], [3,2]

比例: 1:2 (排列是组合的 2 倍，因为每个组合有 2! = 2 种排列)
```

---

## 🔑 关键代码片段（默写版）

### 组合（不可重复）
```javascript
for (let i = start; i <= n; i++) {
    path.push(i);
    backtrack(i + 1);  // 下次从 i+1 开始
    path.pop();
}
```

### 组合（可重复）
```javascript
for (let i = start; i < candidates.length; i++) {
    path.push(candidates[i]);
    backtrack(i, sum + candidates[i]);  // 下次从 i 开始（可以再选 i）
    path.pop();
}
```

### 组合（去重）
```javascript
for (let i = start; i < candidates.length; i++) {
    if (i > start && candidates[i] === candidates[i-1]) continue; // 跳过同层重复
    path.push(candidates[i]);
    backtrack(i + 1, sum + candidates[i]);
    path.pop();
}
```

### 排列（无重复）
```javascript
for (let i = 0; i < nums.length; i++) {
    if (used[i]) continue;
    path.push(nums[i]);
    used[i] = true;
    backtrack();  // 无参数，每次全遍历
    path.pop();
    used[i] = false;
}
```

### 排列（去重）
```javascript
for (let i = 0; i < nums.length; i++) {
    if (used[i]) continue;
    if (i > 0 && nums[i] === nums[i-1] && !used[i-1]) continue; // 相同元素按顺序用
    path.push(nums[i]);
    used[i] = true;
    backtrack();
    path.pop();
    used[i] = false;
}
```

### 电话号码
```javascript
const letters = phoneMap[digits[index]];
for (let letter of letters) {
    path.push(letter);
    backtrack(index + 1);  // 移动到下一个数字位置
    path.pop();
}
```

---

## 🎓 面试默写检验

闭上文档，默写以下代码框架：

- [ ] 组合基础模板（10行）
- [ ] 排列基础模板（13行）
- [ ] 电话号码模板（15行）
- [ ] 组合去重逻辑（1行）
- [ ] 排列去重逻辑（1行）

如果能默写出来，说明你已经掌握了！🎉

