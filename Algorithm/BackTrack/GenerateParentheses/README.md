# 生成括号 (Generate Parentheses)

## 📌 题目描述

LeetCode 22. 生成括号

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]

输入：n = 1
输出：["()"]

输入：n = 2
输出：["(())","()()"]
```

---

## 🎯 核心思路

这是一道典型的回溯问题，但与其他回溯问题不同的是：
- **不需要遍历选择列表**
- **只有两个选择：添加左括号 `(` 或添加右括号 `)`**
- **关键在于什么时候可以添加左/右括号**

### 合法性约束

1. **左括号约束**：左括号数量不能超过 n
2. **右括号约束**：右括号数量不能超过左括号数量（否则会出现 `)(`  这种不合法的情况）
3. **终止条件**：左右括号都用完了（各用了 n 个）

---

## 🔥 回溯树可视化（n = 2）

```
                     ""
                    /  \
                   /    \
              "(1,0)"    不能添加 )，因为 right > left
                /   \
               /     \
          "((2,0)"  "()(1,1)"
            /           \
           /             \
       "(()(2,1)"      "()()(2,1)"  
          /                  \
         /                    \
    "((()))(2,2)" ✅        "()())(2,2)" ✅

说明：
- 括号内数字表示 (left, right)，即已使用的左括号和右括号数量
- ✅ 表示找到一个合法结果
```

### 完整的决策过程（n = 2）

```
步骤1: backtrack("", 0, 0)
       → 可以添加 (，进入步骤2

步骤2: backtrack("(", 1, 0)
       → 可以添加 (，进入步骤3
       → 可以添加 )，进入步骤5

步骤3: backtrack("((", 2, 0)
       → 左括号用完，只能添加 )
       → 进入步骤4

步骤4: backtrack("(()", 2, 1)
       → 只能添加 )
       → 进入步骤4.1

步骤4.1: backtrack("(())", 2, 2)
         → 左右括号都用完了
         → ✅ 收集结果 "(())"
         → 返回

步骤5: backtrack("()", 1, 1)
       → 可以添加 (
       → 进入步骤6

步骤6: backtrack("()(", 2, 1)
       → 左括号用完，只能添加 )
       → 进入步骤7

步骤7: backtrack("()()", 2, 2)
       → 左右括号都用完了
       → ✅ 收集结果 "()()"
       → 返回

最终结果：["(())", "()()"]
```

---

## 💡 为什么这道题特殊？

### 1. 不需要显式的"选择列表"

其他回溯问题通常需要：
```javascript
// 组合问题
for (let i = start; i <= n; i++) {
    path.push(i);
    backtrack(i + 1);
    path.pop();
}

// 排列问题
for (let i = 0; i < nums.length; i++) {
    if (used[i]) continue;
    path.push(nums[i]);
    backtrack();
    path.pop();
}
```

但生成括号问题：
```javascript
// 只有两个选择
if (left < n) {
    backtrack(path + '(', left + 1, right);
}
if (right < left) {
    backtrack(path + ')', left, right + 1);
}
```

### 2. 字符串拼接 vs 数组操作

**方法1：字符串拼接（推荐）**
```javascript
function backtrack(path, left, right) {
    // 直接拼接字符串，不需要撤销
    backtrack(path + '(', left + 1, right);
    backtrack(path + ')', left, right + 1);
}
```

**方法2：数组操作（更符合标准模板）**
```javascript
function backtrack(left, right) {
    // 做选择
    path.push('(');
    backtrack(left + 1, right);
    // 撤销选择
    path.pop();
}
```

### 3. 剪枝条件

这道题的剪枝非常重要：
```javascript
// 如果右括号数量 > 左括号数量，立即返回
if (right > left) return;
```

没有这个剪枝，会生成很多无效的组合（如 `)((`）。

---

## 📊 复杂度分析

### 时间复杂度：O(4^n / √n)

- 这个复杂度来自于 **卡特兰数 (Catalan Number)**
- 第 n 个卡特兰数 = C(n) = (2n)! / ((n+1)! * n!)
- 渐进复杂度为 O(4^n / (n√n))

### 空间复杂度：O(n)

- 递归栈的深度最多为 2n（每次递归要么添加左括号，要么添加右括号）
- 实际有效深度为 n（因为有剪枝）

---

## 🔍 关键点总结

| 特性 | 说明 |
|:-----|:-----|
| **问题类型** | 回溯（但不需要遍历选择列表） |
| **递归参数** | `path`（当前路径）、`left`（已用左括号数）、`right`（已用右括号数） |
| **终止条件** | `left === n && right === n` |
| **剪枝条件** | `right > left`（右括号不能比左括号多） |
| **选择** | 添加 `(` 或添加 `)` |
| **添加 ( 的条件** | `left < n` |
| **添加 ) 的条件** | `right < left` |

---

## 🆚 与其他回溯问题的对比

| 问题类型 | 选择方式 | 防重复机制 | 参数 |
|:--------|:--------|:----------|:-----|
| **组合** | 遍历数组 | `start` 参数 | `backtrack(start)` |
| **排列** | 遍历数组 | `used[]` 数组 | `backtrack()` |
| **子集** | 遍历数组 | `start` 参数 | `backtrack(start)` |
| **生成括号** | 只有两个固定选择 | 通过计数器 `left`/`right` | `backtrack(left, right)` |

---

## 🎓 学习建议

1. **先理解约束条件**：
   - 什么时候可以添加左括号？
   - 什么时候可以添加右括号？
   - 什么时候说明找到一个合法组合？

2. **画出回溯树**：
   - 从 `n = 1` 开始画
   - 理解每个节点的 `(left, right)` 状态
   - 理解为什么有些分支会被剪枝

3. **对比两种实现**：
   - 字符串拼接：简洁，但字符串不可变
   - 数组操作：更符合标准回溯模板

4. **理解为什么不需要撤销**：
   - 使用字符串拼接时，每次递归都创建了新的字符串
   - 使用数组操作时，需要显式撤销（`path.pop()`）

---

## 🔗 相关问题

1. **LeetCode 20. 有效的括号** - 判断括号是否合法（栈）
2. **LeetCode 32. 最长有效括号** - 动态规划/栈
3. **LeetCode 301. 删除无效的括号** - BFS/回溯
4. **LeetCode 678. 有效的括号字符串** - 贪心/动态规划

---

## 💪 练习建议

1. **手写代码**：不看答案，尝试自己实现
2. **添加打印**：在关键位置添加 `console.log`，观察回溯过程
3. **变种练习**：
   - 如果要求生成所有长度为 2n 的括号字符串（不要求合法）怎么写？
   - 如果有多种括号（如 `()`, `[]`, `{}`）怎么处理？
   - 如果要求返回第 k 个合法的括号组合怎么写？

---

## 🚀 运行代码

```bash
node generateParentheses.js
```

你会看到：
- 不同 n 值的测试结果
- 三种方法的结果对比
- 详细的回溯过程演示（n = 2）

