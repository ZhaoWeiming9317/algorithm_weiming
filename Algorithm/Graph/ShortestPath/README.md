# 最短路径算法专题

## 🎯 最短路径问题概述

最短路径问题是图论中的经典问题，目标是找到图中两个顶点之间权重和最小的路径。

### 问题分类
1. **单源最短路径**：从一个源点到所有其他顶点的最短路径
2. **单目标最短路径**：从所有顶点到一个目标顶点的最短路径
3. **单对最短路径**：特定两个顶点之间的最短路径
4. **全源最短路径**：所有顶点对之间的最短路径

### 图的特性
- **无权图**：所有边权重相同，使用BFS
- **非负权图**：边权重非负，使用Dijkstra
- **一般加权图**：可能有负权边，使用Bellman-Ford
- **无负权环**：保证最短路径存在

## 🚀 主要算法

### 1. Dijkstra算法
- **适用**：非负权重的加权图
- **思想**：贪心算法，每次选择距离最小的未访问顶点
- **复杂度**：O(V²) 或 O((V+E)logV) 使用优先队列
- **特点**：不能处理负权边

### 2. Bellman-Ford算法
- **适用**：可能有负权边的图
- **思想**：动态规划，松弛所有边V-1次
- **复杂度**：O(VE)
- **特点**：能检测负权环

### 3. Floyd-Warshall算法
- **适用**：全源最短路径
- **思想**：动态规划，考虑所有中间顶点
- **复杂度**：O(V³)
- **特点**：能处理负权边，不能有负权环

### 4. SPFA算法
- **适用**：可能有负权边的图
- **思想**：Bellman-Ford的队列优化
- **复杂度**：平均O(E)，最坏O(VE)
- **特点**：实际性能通常很好

## 📊 算法对比

| 算法 | 时间复杂度 | 空间复杂度 | 负权边 | 负权环检测 | 适用场景 |
|------|-----------|-----------|--------|-----------|---------|
| **BFS** | O(V+E) | O(V) | ❌ | ❌ | 无权图 |
| **Dijkstra** | O(V²) 或 O((V+E)logV) | O(V) | ❌ | ❌ | 非负权图 |
| **Bellman-Ford** | O(VE) | O(V) | ✅ | ✅ | 有负权边 |
| **Floyd-Warshall** | O(V³) | O(V²) | ✅ | ✅ | 全源最短路径 |
| **SPFA** | O(E) ~ O(VE) | O(V) | ✅ | ✅ | 稀疏图负权边 |

## 🔥 核心概念

### 松弛操作(Relaxation)
```javascript
function relax(u, v, weight, distance) {
    if (distance[u] + weight < distance[v]) {
        distance[v] = distance[u] + weight;
        return true; // 成功松弛
    }
    return false;
}
```

### 最短路径树
- 从源点到所有其他顶点的最短路径构成的树
- 每个顶点只有一个父节点（除了源点）
- 可以通过前驱数组重建路径

### 负权环
- 权重和为负的环
- 如果存在负权环，最短路径可能不存在
- 可以通过多次松弛检测

## 📚 应用场景

### 实际应用
1. **导航系统**：GPS路径规划
2. **网络路由**：数据包路由选择
3. **游戏AI**：NPC路径查找
4. **社交网络**：六度分隔理论
5. **金融**：汇率套利检测
6. **物流**：配送路径优化

### 变种问题
1. **路径计数**：最短路径的数量
2. **次短路径**：第二短的路径
3. **限制条件**：带约束的最短路径
4. **动态图**：边权重动态变化
5. **多目标**：多个目标的最短路径

## 💡 实现要点

### 1. 数据结构选择
- **邻接矩阵**：适合稠密图，Floyd-Warshall
- **邻接表**：适合稀疏图，Dijkstra、Bellman-Ford
- **优先队列**：Dijkstra算法的关键优化

### 2. 距离初始化
```javascript
const distance = new Array(V).fill(Infinity);
distance[source] = 0;
```

### 3. 路径重建
```javascript
function reconstructPath(predecessor, source, target) {
    const path = [];
    let current = target;
    
    while (current !== null) {
        path.unshift(current);
        current = predecessor[current];
    }
    
    return path[0] === source ? path : null;
}
```

## 🎯 算法选择指南

### 单源最短路径
- **无权图** → BFS
- **非负权图** → Dijkstra
- **可能有负权边** → Bellman-Ford 或 SPFA
- **稠密图** → Dijkstra (邻接矩阵)
- **稀疏图** → Dijkstra (优先队列)

### 全源最短路径
- **小图(V ≤ 400)** → Floyd-Warshall
- **大图** → 多次Dijkstra
- **有负权边** → Floyd-Warshall 或 多次Bellman-Ford

### 特殊需求
- **需要检测负权环** → Bellman-Ford
- **实时性要求高** → 预处理 + 查表
- **动态图** → 增量算法

## 🔥 经典问题

### 基础问题
1. **网络延迟时间** - 信号传播的最短时间
2. **最便宜的航班** - 带中转次数限制的最短路径
3. **概率最大的路径** - 变种最短路径问题

### 进阶问题
1. **K短路径** - 找到前K条最短路径
2. **差分约束** - 使用最短路径解决不等式组
3. **最小环** - 找到图中权重最小的环

### 实际应用
1. **地图导航** - 考虑实时交通的路径规划
2. **网络路由** - 多约束条件下的路径选择
3. **游戏寻路** - A*算法在游戏中的应用

## 🚀 优化技巧

### 1. 双向搜索
```javascript
// 从源点和目标点同时搜索
// 当两个搜索相遇时停止
```

### 2. A*算法
```javascript
// Dijkstra + 启发式函数
// 优先扩展更有希望的节点
```

### 3. 分层图
```javascript
// 将复杂约束转换为图的层次结构
// 每层代表不同的状态
```

---

**最短路径算法是图论中最实用的算法之一！**
